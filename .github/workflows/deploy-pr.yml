name: Deploy terraform and frontend to PR environment
# Deployment order: Terraform -> Frontend

on:
  pull_request:
    branches: [master]

jobs:
  # Deploys terraform APIM.
  deploy_apim_terraform:
    name: "Deploy APIM"
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./terraform/env/dev/apim
    env:
      ARM_CLIENT_ID: 1031f58e-c51e-46ea-8803-74e19d760359
      ARM_CLIENT_SECRET: ${{secrets.TF_ARM_CLIENT_SECRET}}
      ARM_SUBSCRIPTION_ID: 12cc0aaa-84e6-49d1-afc3-743c4b0b2d56
      ARM_TENANT_ID: 7bec33a8-0ab6-4da4-9f1f-f5dcbae296db
      TF_INPUT: false

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v2

      - name: Setup Terraform (Azure)
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 0.13.5

      - name: Terraform Init
        id: apim-init
        run: terraform init

      - name: Terraform Validate
        id: apim-validate
        run: terraform validate -no-color

      - name: Terraform Format
        id: apim-fmt
        run: terraform fmt -check

      - name: Terraform Plan
        id: apim-plan
        run: terraform plan -no-color

      - name: Terraform Apply
        id: apim-apply
        run: terraform apply -auto-approve

  # Deploys terraform PR contents.
  deploy_pr_terraform:
    name: "Deploy backend PR environment."
    needs: deploy_apim_terraform
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./terraform/env/dev/pr
    env:
      ARM_CLIENT_ID: 1031f58e-c51e-46ea-8803-74e19d760359
      ARM_CLIENT_SECRET: ${{secrets.TF_ARM_CLIENT_SECRET}}
      ARM_SUBSCRIPTION_ID: 12cc0aaa-84e6-49d1-afc3-743c4b0b2d56
      ARM_TENANT_ID: 7bec33a8-0ab6-4da4-9f1f-f5dcbae296db
      TF_INPUT: false

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v2

      - name: Get Branch Name
        shell: bash
        run: |
          echo "##[set-output name=branch;]$(echo ${GITHUB_HEAD_REF})"
          echo "##[set-output name=branch-subset;]$(echo ${GITHUB_HEAD_REF} | tr -d ' -' | awk '{print tolower(substr( $0, 1, 7))}')"
        id: extract_branch_name

      - name: Setup Terraform (Azure)
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 0.13.5
          terraform_wrapper: false

      - name: Terraform Init
        id: pr-init
        run: terraform init -backend-config="key=digital-hybrid-backend/dev/${{ steps.extract_branch_name.outputs.branch-subset }}/terraform.tfstate"

      - name: Terraform Validate
        id: pr-validate
        run: terraform validate -no-color

      - name: Terraform Format
        id: pr-fmt
        run: terraform fmt -check

      - name: Terraform Plan
        id: pr-plan
        run: terraform plan -no-color
        env:
          TF_VAR_environment_prefix: ${{ steps.extract_branch_name.outputs.branch-subset }}

      - name: Terraform Apply
        id: pr-apply
        run: terraform apply -auto-approve
        env:
          TF_VAR_environment_prefix: ${{ steps.extract_branch_name.outputs.branch-subset }}

      - name: Get Terraform Outputs
        id: get-terraform-outputs
        working-directory: ./terraform/env/dev/pr
        run: |
          echo ::set-output name=frontend-storage-account-name::$( terraform output -json | jq -r .frontend_storage_account_name.value )
          echo ::set-output name=api-endpoints::$( terraform output -json | jq -r .endpoints.value )
          echo ::set-output name=resource-group-name::$( terraform output -json | jq -r .dev_apim_rg.value )
          echo ::set-output name=website-endpoint::$( terraform output -json | jq -r .frontend_web_endpoint.value )
          echo ::set-output name=storybook-web-endpoint::$( terraform output -json | jq -r .storybook_web_endpoint.value )
          echo ::set-output name=storybook-storage-account-name::$( terraform output -json | jq -r .storybook_storage_account_name.value )

    outputs:
      frontend_storage_account_name: ${{ steps.get-terraform-outputs.outputs.frontend-storage-account-name }}
      resource_group_name: ${{ steps.get-terraform-outputs.outputs.resource-group-name }}
      api_endpoints: ${{ steps.get-terraform-outputs.outputs.api-endpoints }}
      website_endpoint: ${{ steps.get-terraform-outputs.outputs.website-endpoint }}
      storybook_storage_account_name: ${{ steps.get-terraform-outputs.outputs.storybook-storage-account-name }}
      storybook_web_endpoint: ${{ steps.get-terraform-outputs.outputs.storybook-web-endpoint }}

  # Deploys frontend pr contents
  deploy_pr_frontend:
    name: "Deploy frontend PR environment"
    needs: [deploy_apim_terraform, deploy_pr_terraform]
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./hybrid-frontend

    strategy:
      matrix:
        node-version: [12.x]

    steps:
      - uses: actions/checkout@v1
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}

      - name: Increase file watchers for Gatsby
        shell: bash
        run: echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p # INvestigating this needed!

      #Get Branch Name on a Pull request, lowercase, 7 char long without dashes
      - name: Get Branch Name
        shell: bash
        run: |
          echo "##[set-output name=branch;]$(echo ${GITHUB_HEAD_REF})"
          echo "##[set-output name=branch-subset;]$(echo ${GITHUB_HEAD_REF} | tr -d ' -' | awk '{print tolower(substr( $0, 1, 7))}')"
        id: extract_branch_name

      - name: Get yarn cache directory path
        id: yarn-cache-dir-path
        run: echo "::set-output name=dir::$(yarn config get cacheFolder)"

      - uses: actions/cache@v2
        id: yarn-cache
        with:
          path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - uses: actions/cache@v2
        id: node-modules-cache
        with:
          path: "**/node_modules"
          key: ${{ runner.os }}-modules-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-modules-

      - name: Install dependencies
        if: ${{ steps.yarn-cache.outputs.cache-hit != 'true' || steps.node-modules-cache.outputs.cache-hit != 'true'}}
        run: |
          npm install -g gatsby-cli
          yarn add

      - name: Run linting and formatting
        run: |
          yarn format:check
          yarn lint

      - name: Run unit tests and code coverage
        run: yarn test:coverage

      - name: Create PR env file
        run: |
          touch .env.pr
          echo 'API_ENDPOINTS=${{ needs.deploy_pr_terraform.outputs.api_endpoints }}' >> .env.pr
          echo "ASSETS_API_BASE_URL=https://digital-hybrid-mgmt.azure-api.net/digitalhybrid/Assets" >> .env.pr
          echo "XPLAN_BASE_URL=https://tbigroupuat2.xplan.iress.co.uk" >> .env.pr
          cat .env.pr

      - name: Run E2E UI tests
        run: |
          npx cypress install
          GATSBY_ACTIVE_ENV=pr yarn test:e2e:ci

      - name: Build with Gatsby
        run: GATSBY_ACTIVE_ENV=pr yarn build

      - name: Login to Azure with Az Powershell
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Setup storage account and deploy static website
        uses: azure/powershell@v1
        with:
          inlineScript: |
            $StorageAccountRG = "${{ needs.deploy_pr_terraform.outputs.resource_group_name }}"
            $StorageAccountName = "${{ needs.deploy_pr_terraform.outputs.frontend_storage_account_name }}"
            $IndexDocumentName = "index.html"
            $ErrorDocumentName = "error.html"
            $sourceFileRootDirectory = "${{ github.workspace }}/hybrid-frontend/public"
            $ContainerName = '$web'
            # $tags = @{"branch"="${{ steps.extract_branch_name.outputs.branch }}"}


            function Upload-FileToAzureStorageContainer {
              [cmdletbinding()]
              param(
                $StorageAccountName,
                $ContainerName,
                $StorageAccountRG,
                $sourceFileRootDirectory,
                $Force
              )

              $storageAccount = Get-AzStorageAccount -ResourceGroupName $StorageAccountRG -AccountName $StorageAccountName
              $ctx = $storageAccount.Context
              $container = Get-AzStorageContainer -Name $ContainerName -Context $ctx

              $container.CloudBlobContainer.Uri.AbsoluteUri
              if ($container) {
                $filesToUpload = Get-ChildItem $sourceFileRootDirectory -Recurse -File

                foreach ($x in $filesToUpload) {
                  $targetPath = ($x.fullname.Substring($sourceFileRootDirectory.Length + 1)).Replace("\", "/")

                  Write-Verbose "Uploading $("\" + $x.fullname.Substring($sourceFileRootDirectory.Length + 1)) to $($container.CloudBlobContainer.Uri.AbsoluteUri + "/" + $targetPath)"
                  Set-AzStorageBlobContent -File $x.fullname -Container $container.Name -Blob $targetPath -Context $ctx -Properties @{"ContentType" = "text/html"} -Force:$Force | Out-Null
                }
              }
            }

            function Remove-AzureStorageBlobs {
              [cmdletbinding()]
              param(
                  $StorageAccountName,
                  $StorageAccountRG,
                  $ContainerName
              )
              $StorageAccount = Get-AzStorageAccount -ResourceGroupName $StorageAccountRG -AccountName $StorageAccountName
              $Context  = $StorageAccount.Context
              if($null -eq $(Get-AzStorageContainer -Name $ContainerName -Context $Context -ErrorAction Ignore)) {
                  Write-Host "[Error] Storage container doesnt exists"
              } else {
                  Write-Host "Storage container exists, deleting all Files in container $ContainerName"
                  (Get-AzStorageBlob -Container $ContainerName -Context $Context | Remove-AzStorageBlob -Force) 1> $null
              }
            }

            if($(Get-AzStorageAccount -ResourceGroupName $StorageAccountRG -Name $StorageAccountName -ErrorAction Ignore) -eq $null) {
              Write-Host "[Error] Storage account doesnt exist"
               Write-Error 'The Storage Account does not exist.' -ErrorAction Stop
              # Write-Host "[1] Storage account doesnt exists, creating new storage account"
             

              # New-AzStorageAccount -Location "West Europe" -Name $StorageAccountName -ResourceGroupName $StorageAccountRG -SkuName Standard_GRS -Kind StorageV2 -Tag $tags
              # Write-Host "[2] New storage account created named $StorageAccountName"

              # Write-Host "[3] Enabling static website hosting"
              # $storageAccount = Get-AzStorageAccount -ResourceGroupName $StorageAccountRG -AccountName $StorageAccountName
              # $ctx = $storageAccount.Context
              # Enable-AzStorageStaticWebsite -Context $ctx -IndexDocument $IndexDocumentName -ErrorDocument404Path $ErrorDocumentName

              # Write-Host "[4] Deploying website"
              # Upload-FileToAzureStorageContainer -StorageAccountName $StorageAccountName -ContainerName $ContainerName -StorageAccountRG $StorageAccountRG -sourceFileRootDirectory $sourceFileRootDirectory -Verbose

            } else {
              Write-Host "[1] Confirm storage account $StorageAccountName exists"
              
              Write-Host "[2] flushing storage account name $StorageAccountName"
              Remove-AzureStorageBlobs -StorageAccountName $StorageAccountName -StorageAccountRG $StorageAccountRG -ContainerName $ContainerName
              
              Write-Host "[3]  Deploying website"
              Upload-FileToAzureStorageContainer -StorageAccountName $StorageAccountName -ContainerName $ContainerName -StorageAccountRG $StorageAccountRG -sourceFileRootDirectory $sourceFileRootDirectory -Verbose
            }

            $storageAccount = Get-AzStorageAccount -ResourceGroupName $StorageAccountRG -AccountName $StorageAccountName
            Write-Host "[FINISH]  Website deployed - see below url"
            Write-Output $storageAccount.PrimaryEndpoints.Web
          azPSVersion: "latest"

      - name: Get PR Website URL
        shell: bash
        run: |
          echo "PR Website Endpoint: ${{ needs.deploy_pr_terraform.outputs.website_endpoint }}"
        id: web_url

  # Terraform plan for Staging
  plan_staging:
    name: "Terraform plan for Staging environment"
    needs: [deploy_apim_terraform, deploy_pr_terraform]
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./terraform/env/staging
    env:
      ARM_CLIENT_ID: 1031f58e-c51e-46ea-8803-74e19d760359
      ARM_CLIENT_SECRET: ${{secrets.TF_ARM_CLIENT_SECRET}}
      ARM_SUBSCRIPTION_ID: 12cc0aaa-84e6-49d1-afc3-743c4b0b2d56
      ARM_TENANT_ID: 7bec33a8-0ab6-4da4-9f1f-f5dcbae296db
      TF_INPUT: false

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v2

      - name: Setup Terraform (Azure)
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 0.13.5
          terraform_wrapper: false

      - name: Terraform Init
        id: staging-init
        run: terraform init

      - name: Terraform Validate
        id: staging-validate
        run: terraform validate -no-color

      - name: Terraform Format
        id: staging-fmt
        run: terraform fmt -check

      - name: Terraform Plan
        id: staging-plan
        run: terraform plan -no-color

  # Terraform plan for Prod
  plan_prod:
    name: "Terraform plan for Prod environment"
    needs: [deploy_apim_terraform, deploy_pr_terraform]
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./terraform/env/prod
    env:
      ARM_CLIENT_ID: 1031f58e-c51e-46ea-8803-74e19d760359
      ARM_CLIENT_SECRET: ${{secrets.TF_ARM_CLIENT_SECRET}}
      ARM_SUBSCRIPTION_ID: 12cc0aaa-84e6-49d1-afc3-743c4b0b2d56
      ARM_TENANT_ID: 7bec33a8-0ab6-4da4-9f1f-f5dcbae296db
      TF_INPUT: false

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v2

      - name: Setup Terraform (Azure)
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 0.13.5
          terraform_wrapper: false

      - name: Terraform Init
        id: prod-init
        run: terraform init

      - name: Terraform Validate
        id: prod-validate
        run: terraform validate -no-color

      - name: Terraform Format
        id: prod-fmt
        run: terraform fmt -check

      - name: Terraform Plan
        id: prod-plan
        run: terraform plan -no-color

  # Deploys storybook.
  deploy_storybook_pr:
    name: "Deploy Storybook"
    needs: [deploy_pr_terraform]
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./hybrid-frontend

    strategy:
      matrix:
        node-version: [12.x]

    steps:
      - uses: actions/checkout@v1
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}

      - name: Get yarn cache directory path
        id: yarn-cache-dir-path
        run: echo "::set-output name=dir::$(yarn config get cacheFolder)"

      - uses: actions/cache@v2
        id: yarn-cache
        with:
          path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - uses: actions/cache@v2
        id: node-modules-cache
        with:
          path: "**/node_modules"
          key: ${{ runner.os }}-modules-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-modules-

      - name: Install dependencies
        if: ${{ steps.yarn-cache.outputs.cache-hit != 'true' || steps.node-modules-cache.outputs.cache-hit != 'true' }}
        run: |
          yarn add

      - name: Build Storybook
        run: yarn build-storybook -o "${{ github.workspace }}/hybrid-frontend/storybook-content"

      - name: Login to Azure with Az Powershell
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Setup storage account and deploy static website
        uses: azure/powershell@v1
        with:
          inlineScript: |
            $StorageAccountRG = "${{ needs.deploy_pr_terraform.outputs.resource_group_name }}"
            $StorageAccountName = "${{ needs.deploy_pr_terraform.outputs.storybook_storage_account_name }}"
            $IndexDocumentName = "index.html"
            $ErrorDocumentName = "error.html"
            $sourceFileRootDirectory = "${{ github.workspace }}/hybrid-frontend/storybook-content"
            $ContainerName = '$web'
            # $tags = @{"branch"="${{ steps.extract_branch_name.outputs.branch }}"}


            function Upload-FileToAzureStorageContainer {
              [cmdletbinding()]
              param(
                $StorageAccountName,
                $ContainerName,
                $StorageAccountRG,
                $sourceFileRootDirectory,
                $Force
              )

              $storageAccount = Get-AzStorageAccount -ResourceGroupName $StorageAccountRG -AccountName $StorageAccountName
              $ctx = $storageAccount.Context
              $container = Get-AzStorageContainer -Name $ContainerName -Context $ctx

              $container.CloudBlobContainer.Uri.AbsoluteUri
              if ($container) {
                $filesToUpload = Get-ChildItem $sourceFileRootDirectory -Recurse -File

                foreach ($x in $filesToUpload) {
                  $targetPath = ($x.fullname.Substring($sourceFileRootDirectory.Length + 1)).Replace("\", "/")

                  Write-Verbose "Uploading $("\" + $x.fullname.Substring($sourceFileRootDirectory.Length + 1)) to $($container.CloudBlobContainer.Uri.AbsoluteUri + "/" + $targetPath)"
                  Set-AzStorageBlobContent -File $x.fullname -Container $container.Name -Blob $targetPath -Context $ctx -Properties @{"ContentType" = "text/html"} -Force:$Force | Out-Null
                }
              }
            }

            function Remove-AzureStorageBlobs {
              [cmdletbinding()]
              param(
                  $StorageAccountName,
                  $StorageAccountRG,
                  $ContainerName
              )
              $StorageAccount = Get-AzStorageAccount -ResourceGroupName $StorageAccountRG -AccountName $StorageAccountName
              $Context  = $StorageAccount.Context
              if($null -eq $(Get-AzStorageContainer -Name $ContainerName -Context $Context -ErrorAction Ignore)) {
                  Write-Host "[Error] Storage container doesnt exists"
              } else {
                  Write-Host "Storage container exists, deleting all Files in container $ContainerName"
                  (Get-AzStorageBlob -Container $ContainerName -Context $Context | Remove-AzStorageBlob -Force) 1> $null
              }
            }

            if($(Get-AzStorageAccount -ResourceGroupName $StorageAccountRG -Name $StorageAccountName -ErrorAction Ignore) -eq $null) {
              Write-Host "[Error] Storage account doesnt exist"
               Write-Error 'The Storage Account does not exist.' -ErrorAction Stop
              # Write-Host "[1] Storage account doesnt exists, creating new storage account"
             

              # New-AzStorageAccount -Location "West Europe" -Name $StorageAccountName -ResourceGroupName $StorageAccountRG -SkuName Standard_GRS -Kind StorageV2 -Tag $tags
              # Write-Host "[2] New storage account created named $StorageAccountName"

              # Write-Host "[3] Enabling static website hosting"
              # $storageAccount = Get-AzStorageAccount -ResourceGroupName $StorageAccountRG -AccountName $StorageAccountName
              # $ctx = $storageAccount.Context
              # Enable-AzStorageStaticWebsite -Context $ctx -IndexDocument $IndexDocumentName -ErrorDocument404Path $ErrorDocumentName

              # Write-Host "[4] Deploying website"
              # Upload-FileToAzureStorageContainer -StorageAccountName $StorageAccountName -ContainerName $ContainerName -StorageAccountRG $StorageAccountRG -sourceFileRootDirectory $sourceFileRootDirectory -Verbose

            } else {
              Write-Host "[1] Confirm storage account $StorageAccountName exists"
              
              Write-Host "[2] flushing storage account name $StorageAccountName"
              Remove-AzureStorageBlobs -StorageAccountName $StorageAccountName -StorageAccountRG $StorageAccountRG -ContainerName $ContainerName
              
              Write-Host "[3]  Deploying website"
              Upload-FileToAzureStorageContainer -StorageAccountName $StorageAccountName -ContainerName $ContainerName -StorageAccountRG $StorageAccountRG -sourceFileRootDirectory $sourceFileRootDirectory -Verbose
            }

            $storageAccount = Get-AzStorageAccount -ResourceGroupName $StorageAccountRG -AccountName $StorageAccountName
            Write-Host "[FINISH]  Website deployed - see below url"
            Write-Output $storageAccount.PrimaryEndpoints.Web
          azPSVersion: "latest"

      - name: Get PR Storybook URL
        shell: bash
        run: |
          echo "Storybook PR Endpoint: ${{ needs.deploy_pr_terraform.outputs.storybook_web_endpoint }}"
        id: storybook_url
